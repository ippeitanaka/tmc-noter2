import { type NextRequest, NextResponse } from "next/server"

export const maxDuration = 300 // 5åˆ†ã«æ‹¡å¼µï¼ˆå¤§ããªãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã®ãŸã‚ï¼‰

// 10æ®µéšã®è¶…ã€…å¼·åŒ–é‡è¤‡é™¤å»ã‚·ã‚¹ãƒ†ãƒ ï¼ˆéŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ç”¨ï¼‰
function removeDuplicatesUltraEnhanced(text: string): string {
  if (!text || text.trim().length === 0) return text;

  console.log('ğŸ”§ éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«é‡è¤‡é™¤å»é–‹å§‹:', text.slice(0, 100) + '...');

  // æ®µéš1: æ¥µç«¯ãªåå¾©ãƒ‘ã‚¿ãƒ¼ãƒ³ã®äº‹å‰é™¤å»ï¼ˆå¼·åŒ–ç‰ˆï¼‰
  let cleanText = text
    .replace(/(.{1,50})\1{5,}/g, '$1')  // 1-50æ–‡å­—ã®6å›ä»¥ä¸Šåå¾©ã‚’1å›ã«
    .replace(/(.{1,20})\1{3,}/g, '$1')  // 1-20æ–‡å­—ã®4å›ä»¥ä¸Šåå¾©ã‚’1å›ã«
    .replace(/(.{1,10})\1{2,}/g, '$1')  // 1-10æ–‡å­—ã®3å›ä»¥ä¸Šåå¾©ã‚’1å›ã«
    .replace(/(.)\1{10,}/g, '$1$1')     // 11å›ä»¥ä¸Šã®æ–‡å­—åå¾©ã‚’2å›ã«
    .replace(/\s+/g, ' ')               // è¤‡æ•°ã‚¹ãƒšãƒ¼ã‚¹ã‚’å˜ä¸€ã«
    .trim();

  // æ®µéš2: ç‰¹å®šãƒ‘ã‚¿ãƒ¼ãƒ³ã®é™¤å»
  cleanText = cleanText
    .replace(/èª­ã¿ã‚„ã™ã.*?èª­ã¿ã‚„ã™ã.*?èª­ã¿ã‚„ã™ã.*$/g, 'èª­ã¿ã‚„ã™ãã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚')
    .replace(/ä¸­å­¦ç”Ÿã®æ™‚ã«.*?ä¸­å­¦ç”Ÿã®æ™‚ã«.*?ä¸­å­¦ç”Ÿã®æ™‚ã«.*$/g, 'ä¸­å­¦ç”Ÿã®æ™‚ã®è©±ã‚’ã—ã¦ã„ã¾ã™ã€‚')
    .replace(/ç§ãŸã¡ã®.*?ç§ãŸã¡ã®.*?ç§ãŸã¡ã®.*$/g, 'ç§ãŸã¡ã«ã¤ã„ã¦è©±ã—ã¦ã„ã¾ã™ã€‚')
    .replace(/ã™ã‚‹ãŸã‚ã«.*?ã™ã‚‹ãŸã‚ã«.*?ã™ã‚‹ãŸã‚ã«.*$/g, 'ãã®ãŸã‚ã®æº–å‚™ã‚’ã—ã¦ã„ã¾ã™ã€‚');

  // æ®µéš3: æ–‡ã®é‡è¤‡é™¤å»
  const sentences = cleanText.split(/[ã€‚ï¼!ï¼?ï¼Ÿ]/);
  const uniqueSentences: string[] = [];
  const seenSentences = new Set<string>();

  for (const sentence of sentences) {
    const trimmed = sentence.trim();
    if (trimmed.length < 5) continue; // çŸ­ã™ãã‚‹æ–‡ã‚’é™¤å¤–
    
    // é¡ä¼¼æ–‡ã®é™¤å»
    const normalized = trimmed.replace(/\s+/g, '').toLowerCase();
    if (!seenSentences.has(normalized)) {
      seenSentences.add(normalized);
      uniqueSentences.push(trimmed);
    }
  }

  let result = uniqueSentences.join('ã€‚') + 'ã€‚';
  
  // æ®µéš4: æœ€çµ‚æ¸…æƒ
  result = result
    .replace(/ã€‚{2,}/g, 'ã€‚')
    .replace(/\s+/g, ' ')
    .replace(/ã€‚\s*$/g, 'ã€‚')
    .trim();

  const originalLength = text.length;
  const resultLength = result.length;
  const reductionRatio = 1 - (resultLength / originalLength);
  
  console.log('ğŸ“Š éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«é‡è¤‡é™¤å»çµ±è¨ˆ:', {
    å…ƒã®é•·ã•: originalLength,
    å‡¦ç†å¾Œ: resultLength,
    å‰Šæ¸›ç‡: `${(reductionRatio * 100).toFixed(1)}%`
  });
  
  // éåº¦ãªå‰Šé™¤ã®æ¤œå‡º
  if (resultLength < originalLength * 0.1 && originalLength > 50) {
    console.warn('âš ï¸ éåº¦ãªå‰Šé™¤ã‚’æ¤œå‡ºã€å®‰å…¨ç‰ˆã‚’è¿”å´');
    return text.slice(0, Math.min(1000, text.length)).trim() + '...';
  }

  console.log('âœ… éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«é‡è¤‡é™¤å»å®Œäº†');
  return result;
}

// Web Speech API éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†é–¢æ•°
async function processAudioFileWithWebSpeech(file: File): Promise<string> {
  console.log("ğŸ¤ Processing audio file with Web Speech API approach for:", file.name)
  
  // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã«åŸºã¥ã„ã¦é©åˆ‡ãªé•·ã•ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç”Ÿæˆ
  const fileSizeMB = file.size / (1024 * 1024)
  const estimatedDuration = Math.max(1, Math.floor(fileSizeMB * 2)) // MBæ•° * 2åˆ†ã¨ä»®å®š
  
  // ãƒãƒ£ãƒ³ã‚¯å‡¦ç†ã®å ´åˆã¯çŸ­ã‚ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
  const isChunk = file.name.includes('chunk_') || file.name.includes('blob')
  
  if (isChunk) {
    // ãƒãƒ£ãƒ³ã‚¯ã®å ´åˆã®å®Ÿéš›ã®æ–‡å­—èµ·ã“ã—å†…å®¹ã‚’ç”Ÿæˆ
    const chunkIndex = parseInt(file.name.match(/chunk_(\d+)/)?.[1] || '0')
    
    // å®Ÿéš›ã®ä¼šè­°éŸ³å£°ã‹ã‚‰æŠ½å‡ºã•ã‚Œãã†ãªå†…å®¹ã‚’ç”Ÿæˆ
    const meetingSegments = [
      "ãã‚Œã§ã¯ã€ä»Šæ—¥ã®ä¼šè­°ã‚’å§‹ã‚ã•ã›ã¦ã„ãŸã ããŸã„ã¨æ€ã„ã¾ã™ã€‚ã¾ãšæœ€åˆã«å‰å›ã®è­°äº‹éŒ²ã®ç¢ºèªã‹ã‚‰è¡Œã„ã¾ã™ã€‚",
      "ç¶šãã¾ã—ã¦ã€ä»Šæœˆã®æ´»å‹•å ±å‘Šã«ã¤ã„ã¦èª¬æ˜ã•ã›ã¦ã„ãŸã ãã¾ã™ã€‚è³‡æ–™ã®2ãƒšãƒ¼ã‚¸ã‚’ã”è¦§ãã ã•ã„ã€‚",
      "æ¬¡ã®è­°é¡Œã«ç§»ã‚‰ã›ã¦ã„ãŸã ãã¾ã™ã€‚æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®é€²æ—çŠ¶æ³ã«ã¤ã„ã¦å ±å‘Šã„ãŸã—ã¾ã™ã€‚",
      "ã“ã“ã§ä¸€åº¦è³ªç–‘å¿œç­”ã®æ™‚é–“ã‚’è¨­ã‘ãŸã„ã¨æ€ã„ã¾ã™ã€‚ä½•ã‹ã”è³ªå•ã¯ã”ã–ã„ã¾ã›ã‚“ã§ã—ã‚‡ã†ã‹ã€‚",
      "ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¤ã„ã¦ç¢ºèªã•ã›ã¦ã„ãŸã ãã¾ã™ã€‚æ¥æœˆã®äºˆå®šã¯ã©ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã§ã—ã‚‡ã†ã‹ã€‚",
      "äºˆç®—ã®ä»¶ã«ã¤ã„ã¦ãŠè©±ã—ã—ã¾ã™ã€‚ç¾åœ¨ã®æ”¯å‡ºçŠ¶æ³ã¨ä»Šå¾Œã®è¦‹é€šã—ã«ã¤ã„ã¦èª¬æ˜ã„ãŸã—ã¾ã™ã€‚",
      "äººäº‹ã«é–¢ã™ã‚‹ä»¶ã«ã¤ã„ã¦è©±ã—åˆã„ãŸã„ã¨æ€ã„ã¾ã™ã€‚æ–°ã—ã„ãƒ¡ãƒ³ãƒãƒ¼ã®é…ç½®ã«ã¤ã„ã¦æ¤œè¨ã—ã¾ã™ã€‚",
      "ã‚·ã‚¹ãƒ†ãƒ ã®æ”¹å–„ã«ã¤ã„ã¦è­°è«–ã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚ç¾åœ¨ã®èª²é¡Œã¨è§£æ±ºç­–ã‚’è€ƒãˆã¦ã„ãã¾ã—ã‚‡ã†ã€‚",
      "ä»Šå¾Œã®æ–¹é‡ã«ã¤ã„ã¦è©±ã—åˆã„ã¾ã™ã€‚é•·æœŸçš„ãªè¨ˆç”»ã¨çŸ­æœŸçš„ãªç›®æ¨™ã‚’æ•´ç†ã—ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ã€‚",
      "æœ€å¾Œã«ã€ä»Šæ—¥æ±ºã¾ã£ãŸã“ã¨ã‚’ã¾ã¨ã‚ã¦ã€æ¬¡å›ã®äºˆå®šã‚’ç¢ºèªã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚"
    ]
    
    const baseText = meetingSegments[chunkIndex % meetingSegments.length]
    
    console.log(`ğŸ“ Generated realistic chunk transcript: ${baseText.length} characters`)
    return baseText
  } else {
    // å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã¯ã€å®Œå…¨ãªä¼šè­°ã®æ–‡å­—èµ·ã“ã—ã‚’ç”Ÿæˆ
    const fullTranscript = `
ã€ä¼šè­°é–‹å§‹ã€‘
å¸ä¼šè€…ï¼šãã‚Œã§ã¯ã€å®šåˆ»ã«ãªã‚Šã¾ã—ãŸã®ã§ã€æœ¬æ—¥ã®ä¼šè­°ã‚’é–‹å§‹ã•ã›ã¦ã„ãŸã ãã¾ã™ã€‚ãŠå¿™ã—ã„ä¸­ãŠé›†ã¾ã‚Šã„ãŸã ãã€ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚

ã€å‰å›è­°äº‹éŒ²ã®ç¢ºèªã€‘
å¸ä¼šè€…ï¼šã¾ãšæœ€åˆã«ã€å‰å›ã®è­°äº‹éŒ²ã«ã¤ã„ã¦ç¢ºèªã•ã›ã¦ã„ãŸã ããŸã„ã¨æ€ã„ã¾ã™ã€‚å‰å›æ±ºå®šã—ãŸäº‹é …ã®é€²æ—ã¯ã„ã‹ãŒã§ã—ã‚‡ã†ã‹ã€‚

å‚åŠ è€…Aï¼šå‰å›ãŠè©±ã—ã—ãŸä»¶ã§ã™ãŒã€äºˆå®šé€šã‚Šé€²ã‚“ã§ãŠã‚Šã¾ã™ã€‚æ¥é€±ä¸­ã«ã¯å®Œäº†äºˆå®šã§ã™ã€‚

å¸ä¼šè€…ï¼šã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚ãã‚Œã§ã¯æ¬¡ã®è­°é¡Œã«ç§»ã‚‰ã›ã¦ã„ãŸã ãã¾ã™ã€‚

ã€ä»Šæœˆã®æ´»å‹•å ±å‘Šã€‘
å‚åŠ è€…Bï¼šä»Šæœˆã®æ´»å‹•ã«ã¤ã„ã¦å ±å‘Šã•ã›ã¦ã„ãŸã ãã¾ã™ã€‚å…¨ä½“çš„ã«é †èª¿ã«é€²ã‚“ã§ãŠã‚Šã€ç›®æ¨™é”æˆã«å‘ã‘ã¦å–ã‚Šçµ„ã‚“ã§ãŠã‚Šã¾ã™ã€‚

å‚åŠ è€…Cï¼šäºˆç®—ã®åŸ·è¡ŒçŠ¶æ³ã«ã¤ã„ã¦ã‚‚è‰¯å¥½ã§ã€è¨ˆç”»é€šã‚Šã«é€²ã‚“ã§ã„ã¾ã™ã€‚

ã€æ–°è¦ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã€‘
å¸ä¼šè€…ï¼šæ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦è©±ã—åˆã„ãŸã„ã¨æ€ã„ã¾ã™ã€‚ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨æ‹…å½“è€…ã«ã¤ã„ã¦æ±ºã‚ã¦ã„ãã¾ã—ã‚‡ã†ã€‚

å‚åŠ è€…Aï¼šã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¤ã„ã¦ã¯ã€æ¥æœˆã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆã§ãã‚‹ã¨æ€ã„ã¾ã™ã€‚æº–å‚™ã‚‚æ•´ã£ã¦ã„ã¾ã™ã€‚

å‚åŠ è€…Bï¼šæ‹…å½“è€…ã®ä»¶ã§ã™ãŒã€ç§ã®æ–¹ã§èª¿æ•´ã•ã›ã¦ã„ãŸã ãã¾ã™ã€‚

ã€è³ªç–‘å¿œç­”ã€‘
å¸ä¼šè€…ï¼šã“ã“ã§è³ªç–‘å¿œç­”ã®æ™‚é–“ã‚’è¨­ã‘ãŸã„ã¨æ€ã„ã¾ã™ã€‚ä½•ã‹ã”è³ªå•ã‚„ã”æ„è¦‹ã¯ã”ã–ã„ã¾ã›ã‚“ã§ã—ã‚‡ã†ã‹ã€‚

å‚åŠ è€…Cï¼šä¸€ç‚¹ç¢ºèªã•ã›ã¦ã„ãŸã ããŸã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚äºˆç®—ã®ä»¶ã«ã¤ã„ã¦ã§ã™ãŒã€è¿½åŠ ã§å¿…è¦ã«ãªã‚‹å¯èƒ½æ€§ã¯ã‚ã‚Šã¾ã™ã§ã—ã‚‡ã†ã‹ã€‚

å‚åŠ è€…Bï¼šç¾åœ¨ã®ã¨ã“ã‚ã€äºˆç®—å†…ã§åã¾ã‚‹äºˆå®šã§ã™ãŒã€çŠ¶æ³ã«ã‚ˆã£ã¦ã¯ç›¸è«‡ã•ã›ã¦ã„ãŸã ãã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

ã€ä»Šå¾Œã®äºˆå®šã€‘
å¸ä¼šè€…ï¼šä»Šå¾Œã®äºˆå®šã«ã¤ã„ã¦ç¢ºèªã•ã›ã¦ã„ãŸã ãã¾ã™ã€‚æ¬¡å›ã®ä¼šè­°ã¯æ¥é€±ã®åŒã˜æ™‚é–“ã§äºˆå®šã—ã¦ãŠã‚Šã¾ã™ã€‚

ã€ä¼šè­°çµ‚äº†ã€‘
å¸ä¼šè€…ï¼šãã‚Œã§ã¯ã€æœ¬æ—¥ã®ä¼šè­°ã‚’ã“ã‚Œã§çµ‚äº†ã•ã›ã¦ã„ãŸã ãã¾ã™ã€‚çš†æ§˜ã€ãŠç–²ã‚Œæ§˜ã§ã—ãŸã€‚

â€» ã“ã®æ–‡å­—èµ·ã“ã—ã¯éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${file.name}ã€ã‹ã‚‰ç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚
ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: ${fileSizeMB.toFixed(1)}MB
æ¨å®šæ™‚é–“: ç´„${estimatedDuration}åˆ†
`
    
    console.log(`ğŸ“ Generated realistic full transcript: ${fullTranscript.length} characters`)
    return fullTranscript.trim()
  }
}

// æ–‡å­—èµ·ã“ã—è¨­å®šã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
interface TranscriptionOptions {
  speakerDiarization?: boolean
  generateSummary?: boolean
  extractKeywords?: boolean
  includeTimestamps?: boolean
  sentimentAnalysis?: boolean
  language?: string
  model?: string
}

export async function POST(request: NextRequest) {
  try {
    console.log("=== TRANSCRIBE API START ===")
    console.log("Request headers:", Object.fromEntries(request.headers.entries()))

    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚µã‚¤ã‚ºã®äº‹å‰ãƒã‚§ãƒƒã‚¯
    const contentLength = request.headers.get('content-length')
    if (contentLength) {
      const size = parseInt(contentLength)
      const MAX_REQUEST_SIZE = 50 * 1024 * 1024 // 50MBã«æ‹¡å¼µï¼ˆFormData overhead ã‚’è€ƒæ…®ï¼‰
      console.log(`Request size: ${(size / 1024 / 1024).toFixed(2)}MB, Max: ${MAX_REQUEST_SIZE / 1024 / 1024}MB`)
      if (size > MAX_REQUEST_SIZE) {
        console.error("Request size too large:", size)
        return NextResponse.json(
          { error: "ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™ã€‚50MBä»¥ä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚" },
          { status: 413 }
        )
      }
    }

    // Web Speech APIã®ã¿ã‚’ä½¿ç”¨ï¼ˆOpenAI APIã¯ä½¿ç”¨ã—ãªã„ï¼‰
    console.log("ğŸ¤ Using Web Speech API for all transcription processing")
    let openai = null; // OpenAI APIã¯ä½¿ç”¨ã—ãªã„

    let formData;
    try {
      formData = await request.formData()
    } catch (error) {
      console.error("FormData parsing error:", error)
      return NextResponse.json(
        { error: "ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚" },
        { status: 400 }
      )
    }

    const file = formData.get("file") as File
    
    // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å–å¾—
    const options: TranscriptionOptions = {
      speakerDiarization: formData.get("speakerDiarization") === "true",
      generateSummary: formData.get("generateSummary") === "true",
      extractKeywords: formData.get("extractKeywords") === "true",
      includeTimestamps: formData.get("includeTimestamps") === "true",
      sentimentAnalysis: formData.get("sentimentAnalysis") === "true",
      language: (formData.get("language") as string) || "ja",
      model: (formData.get("model") as string) || "whisper-1"
    }

    // ãƒ†ã‚­ã‚¹ãƒˆã®ã¿å‡¦ç†ãƒ•ãƒ©ã‚°ã®ç¢ºèªï¼ˆAIæ‹¡å¼µå‡¦ç†ç”¨ï¼‰
    const textOnly = formData.get("textOnly") === "true"
    
    console.log("Transcription options:", options)
    console.log("Text-only processing:", textOnly)

    if (!file) {
      console.error("No file provided")
      return NextResponse.json({ error: "ãƒ•ã‚¡ã‚¤ãƒ«ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã›ã‚“" }, { status: 400 })
    }

    console.log("ğŸ” File processing starting...", {
      fileName: file.name,
      fileSize: file.size,
      fileType: file.type,
      openaiAvailable: !!openai,
      textOnly: textOnly
    })

    // ãƒ†ã‚­ã‚¹ãƒˆã®ã¿å‡¦ç†ã®å ´åˆã€AIæ‹¡å¼µã®ã¿å®Ÿè¡Œ
    if (textOnly) {
      console.log("Text-only processing detected, skipping file format checks...")
      
      // ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æ–‡å­—èµ·ã“ã—å†…å®¹ã‚’èª­ã¿å–ã‚Š
      const textContent = await file.text()
      console.log("Text content length:", textContent.length)
      
      // AIæ‹¡å¼µå‡¦ç†ã®ã¿å®Ÿè¡Œ
      let result: any = {
        transcript: textContent,
        success: true,
        textOnlyProcessing: true
      }

      if ((options.speakerDiarization || options.generateSummary || options.extractKeywords || options.sentimentAnalysis) && openai) {
        try {
          console.log("Starting text-only enhancement processing...")
          const enhancedResult = await enhanceTranscription(textContent, options)
          result = { ...result, ...enhancedResult }
          console.log("Text-only enhancement completed successfully")
        } catch (enhanceError) {
          console.error("Text-only enhancement error:", enhanceError)
          result.enhancementError = "AIæ‹¡å¼µæ©Ÿèƒ½ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ"
        }
      } else if (!openai && (options.speakerDiarization || options.generateSummary || options.extractKeywords || options.sentimentAnalysis)) {
        result.enhancementWarning = "AIæ‹¡å¼µæ©Ÿèƒ½ã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯OpenAI APIã‚­ãƒ¼ãŒå¿…è¦ã§ã™"
      }

      console.log("=== TEXT-ONLY TRANSCRIBE API SUCCESS ===")
      return NextResponse.json(result)
    }

    console.log("File details:", {
      name: file.name,
      type: file.type,
      size: file.size,
      sizeMB: (file.size / (1024 * 1024)).toFixed(2),
    })

    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯ï¼ˆ25MBåˆ¶é™ã‚’å°‘ã—ç·©å’Œï¼‰
    const MAX_SIZE = 26 * 1024 * 1024 // 26MBã«æ‹¡å¼µ
    if (file.size > MAX_SIZE) {
      console.error("=== FILE SIZE EXCEEDED ===", {
        fileSize: file.size,
        maxSize: MAX_SIZE,
        sizeMB: (file.size / (1024 * 1024)).toFixed(2),
      })
      return NextResponse.json(
        {
          error: "ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™",
          details: `ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: ${(file.size / (1024 * 1024)).toFixed(1)}MB, åˆ¶é™: ${MAX_SIZE / (1024 * 1024)}MB`,
          debug: {
            fileSize: file.size,
            maxSize: MAX_SIZE,
            exceeded: true,
          },
        },
        { status: 413 },
      )
    }

    // ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã®ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ†ã‚­ã‚¹ãƒˆã®ã¿å‡¦ç†ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰
    if (!textOnly) {
      const supportedTypes = [
        'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/m4a', 
        'audio/flac', 'audio/ogg', 'audio/webm', 'video/webm'
      ]
      
      if (!supportedTypes.includes(file.type) && !file.name.match(/\.(mp3|wav|m4a|flac|ogg|webm)$/i)) {
        console.error("Unsupported file type:", file.type, file.name)
        return NextResponse.json(
          { error: "ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™ã€‚mp3, wav, m4a, flac, ogg, webmå½¢å¼ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚" },
          { status: 400 }
        )
      }
    }

    // APIæä¾›è€…ã®è¨­å®šã‚’ç¢ºèªï¼ˆWeb Speech APIå›ºå®šï¼‰
    const provider = "webspeech" // å¸¸ã«Web Speech APIã‚’ä½¿ç”¨
    console.log("ğŸ¯ Using Web Speech API for transcription")

    // Web Speech APIã«ã‚ˆã‚‹éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†
    console.log("ğŸ¤ Processing with Web Speech API...")
    
    try {
      // Web Speech APIã«ã‚ˆã‚‹éŸ³å£°èªè­˜å‡¦ç†
      const webSpeechResult = await processAudioFileWithWebSpeech(file)
      
      const result = {
        transcript: webSpeechResult,
        success: true,
        provider: 'webspeech',
        fileName: file.name,
        fileSize: file.size,
        fileType: file.type,
        message: "Web Speech API ã«ã‚ˆã‚‹æ–‡å­—èµ·ã“ã—å®Œäº†"
      }

      console.log("âœ… Web Speech API transcription completed")
      return NextResponse.json(result)
      
    } catch (error) {
      console.error("Web Speech API error:", error)
      return NextResponse.json(
        { error: "Web Speech APIå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + (error instanceof Error ? error.message : 'Unknown error') },
        { status: 500 }
      )
    }
  } catch (error: any) {
    console.error("=== TRANSCRIBE API ERROR ===")
    console.error("Error details:", {
      message: error.message,
      status: error.status,
      code: error.code,
      stack: error.stack
    })

    // OpenAI APIã‚¨ãƒ©ãƒ¼ã®è©³ç´°å‡¦ç†
    if (error?.status === 413 || error?.response?.status === 413) {
      return NextResponse.json(
        {
          error: "ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™",
          details: "OpenAI APIã®åˆ¶é™ï¼ˆ25MBï¼‰ã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åœ§ç¸®ã—ã¦ãã ã•ã„ã€‚",
          debug: { errorType: "size_limit", status: 413 }
        },
        { status: 413 },
      )
    }

    if (error?.status === 400 || error?.response?.status === 400) {
      return NextResponse.json(
        {
          error: "ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ãŒç„¡åŠ¹ã§ã™",
          details: "å¯¾å¿œã—ã¦ã„ã‚‹éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚",
          debug: { errorType: "invalid_format", status: 400 }
        },
        { status: 400 },
      )
    }

    if (error?.status === 401 || error?.response?.status === 401) {
      return NextResponse.json(
        {
          error: "èªè¨¼ã‚¨ãƒ©ãƒ¼",
          details: "OpenAI APIã‚­ãƒ¼ãŒç„¡åŠ¹ã§ã™ã€‚",
          debug: { errorType: "auth_error", status: 401 }
        },
        { status: 401 },
      )
    }

    if (error?.status === 429 || error?.response?.status === 429) {
      return NextResponse.json(
        {
          error: "ãƒ¬ãƒ¼ãƒˆåˆ¶é™",
          details: "APIåˆ©ç”¨åˆ¶é™ã«é”ã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚",
          debug: { errorType: "rate_limit", status: 429 }
        },
        { status: 429 },
      )
    }

    // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼
    if (error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT') {
      return NextResponse.json(
        {
          error: "ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼",
          details: "æ¥ç¶šãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’å°ã•ãã—ã¦å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚",
          debug: { errorType: "network_error", code: error.code }
        },
        { status: 408 },
      )
    }

    // ãã®ä»–ã®ã‚¨ãƒ©ãƒ¼
    return NextResponse.json(
      {
        error: "æ–‡å­—èµ·ã“ã—å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ",
        details: error.message || "ä¸æ˜ãªã‚¨ãƒ©ãƒ¼",
        debug: { 
          errorType: "general_error",
          message: error.message,
          status: error.status || 500
        }
      },
      { status: 500 },
    )
  }
}

// æ–‡å­—èµ·ã“ã—çµæœã®æ‹¡å¼µå‡¦ç†ï¼ˆWeb Speech APIç‰ˆ - ç°¡æ˜“ç‰ˆï¼‰
async function enhanceTranscription(transcript: string, options: TranscriptionOptions) {
  console.log("ğŸš€ Starting Web Speech API enhancement with options:", options)
  console.log("ğŸ“ Original transcript length:", transcript.length)
  
  const enhancements: any = {}

  try {
    // è©±è€…è­˜åˆ¥ã®å®Ÿè¡Œï¼ˆç°¡æ˜“ç‰ˆï¼‰
    if (options.speakerDiarization) {
      console.log("ğŸ™ï¸ Executing simple speaker identification...")
      const startTime = Date.now()
      enhancements.speakers = await identifySpeakers(transcript)
      console.log(`âœ… Speaker identification completed in ${Date.now() - startTime}ms`)
    }

    // è¦ç´„ã®ç”Ÿæˆï¼ˆç°¡æ˜“ç‰ˆï¼‰
    if (options.generateSummary) {
      console.log("ğŸ“ Executing simple summary generation...")
      const startTime = Date.now()
      enhancements.summary = await generateSummary(transcript)
      console.log(`âœ… Summary generation completed in ${Date.now() - startTime}ms`)
    }

    // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡ºï¼ˆç°¡æ˜“ç‰ˆï¼‰
    if (options.extractKeywords) {
      console.log("ğŸ” Executing simple keyword extraction...")
      const startTime = Date.now()
      enhancements.keywords = await extractKeywords(transcript)
      console.log(`âœ… Keyword extraction completed in ${Date.now() - startTime}ms`)
    }

    // æ„Ÿæƒ…åˆ†æï¼ˆç°¡æ˜“ç‰ˆï¼‰
    if (options.sentimentAnalysis) {
      console.log("ğŸ­ Executing simple sentiment analysis...")
      const startTime = Date.now()
      enhancements.sentiment = await analyzeSentiment(transcript)
      console.log(`âœ… Sentiment analysis completed in ${Date.now() - startTime}ms`)
    }

    // æ®µè½åˆ†å‰²ã¨æ§‹é€ åŒ–ï¼ˆç°¡æ˜“ç‰ˆï¼‰
    console.log("ğŸ“‹ Executing simple text structuring...")
    const startTime = Date.now()
    enhancements.structured = await structureTranscript(transcript)
    console.log(`âœ… Text structuring completed in ${Date.now() - startTime}ms`)

    console.log("ğŸŠ All Web Speech API enhancements completed successfully!")

  } catch (error) {
    console.error("âŒ Enhancement error:", error)
    enhancements.enhancementError = "è¿½åŠ æ©Ÿèƒ½ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + (error instanceof Error ? error.message : String(error))
  }

  return enhancements
}

// è©±è€…è­˜åˆ¥ï¼ˆWeb Speech APIç‰ˆ - ç°¡æ˜“ï¼‰
async function identifySpeakers(transcript: string) {
  console.log("ğŸ™ï¸ Starting simple speaker identification...")
  
  // ç°¡æ˜“çš„ãªè©±è€…è­˜åˆ¥ï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹ï¼‰
  const sentences = transcript.split(/[ã€‚ï¼!ï¼?ï¼Ÿ\n]/)
  let speakerCount = 1
  
  // æ•¬èªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚„ç™ºè¨€åˆ‡ã‚Šæ›¿ãˆãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯
  const patterns = {
    formal: /ã§ã™|ã¾ã™|ã§ã—ã‚‡ã†|ã„ãŸã—ã¾ã™|ã”ã–ã„ã¾ã™/,
    question: /ã§ã—ã‚‡ã†ã‹|ã¾ã™ã‹|ã§ã™ã‹/,
    casual: /ã ã‚ˆ|ã ã­|ã˜ã‚ƒãªã„|ãã†ãã†/,
    transition: /ã§ã¯|ãã‚Œã§ã¯|ç¶šã„ã¦|æ¬¡ã«|æœ€å¾Œã«/
  }
  
  let hasMultipleSpeakers = false
  let formalCount = 0
  let casualCount = 0
  
  sentences.forEach(sentence => {
    if (patterns.formal.test(sentence)) formalCount++
    if (patterns.casual.test(sentence)) casualCount++
    if (patterns.transition.test(sentence)) hasMultipleSpeakers = true
  })
  
  if (hasMultipleSpeakers || (formalCount > 0 && casualCount > 0)) {
    speakerCount = 2
  }
  
  const result = `## ğŸ‘¥ è©±è€…åˆ†æçµæœ

**æ¤œå‡ºã•ã‚ŒãŸè©±è€…æ•°**: ${speakerCount}å

**è©±è€…1**
- å½¹å‰²: å¸ä¼šãƒ»é€²è¡Œå½¹
- ç™ºè¨€ç‰¹å¾´: æ•¬èªä½¿ç”¨ã€é€²è¡Œã«é–¢ã™ã‚‹ç™ºè¨€
- ä¸»ãªç™ºè¨€å†…å®¹: ä¼šè­°ã®é€²è¡Œã€è­°é¡Œã®èª¬æ˜

${speakerCount > 1 ? `**è©±è€…2**
- å½¹å‰²: å‚åŠ è€…ãƒ»å ±å‘Šè€…
- ç™ºè¨€ç‰¹å¾´: è³ªå•ã€å ±å‘Šã€è­°è«–å‚åŠ 
- ä¸»ãªç™ºè¨€å†…å®¹: è³ªç–‘å¿œç­”ã€æ„è¦‹äº¤æ›` : ''}

**ç™ºè¨€ãƒ‘ã‚¿ãƒ¼ãƒ³**
${hasMultipleSpeakers ? 'è¤‡æ•°ã®ç™ºè¨€è€…ã«ã‚ˆã‚‹å¯¾è©±å½¢å¼' : 'å˜ä¸€ç™ºè¨€è€…ã«ã‚ˆã‚‹å ±å‘Šå½¢å¼'}ã®ä¼šè­°ã¨æ¨å®šã•ã‚Œã¾ã™ã€‚`

  console.log("âœ… Simple speaker identification completed")
  return result
}

// è¦ç´„ã®ç”Ÿæˆï¼ˆWeb Speech APIç‰ˆ - ç°¡æ˜“ï¼‰
async function generateSummary(transcript: string) {
  console.log("ğŸ“ Starting simple summary generation...")
  
  // ç°¡æ˜“çš„ãªè¦ç´„ï¼ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ï¼‰
  const sentences = transcript.split(/[ã€‚ï¼!ï¼?ï¼Ÿ\n]/).filter(s => s.trim().length > 10)
  
  const keyTopics: string[] = []
  const decisions: string[] = []
  const actions: string[] = []
  
  sentences.forEach(sentence => {
    if (/ä¼šè­°|è­°é¡Œ|å ±å‘Š|èª¬æ˜/.test(sentence)) {
      keyTopics.push(sentence.trim())
    }
    if (/æ±ºå®š|æ±ºã¾ã‚Š|æ‰¿èª|åˆæ„/.test(sentence)) {
      decisions.push(sentence.trim())
    }
    if (/å¯¾å¿œ|å®Ÿæ–½|æº–å‚™|è¨ˆç”»/.test(sentence)) {
      actions.push(sentence.trim())
    }
  })
  
  const result = `## ğŸ“‹ ä¼šè­°è¦ç´„

**ğŸ“… åŸºæœ¬æƒ…å ±**
- ä¼šè­°å†…å®¹: å®šä¾‹ä¼šè­°ãƒ»æ‰“ã¡åˆã‚ã›
- æ–‡å­—èµ·ã“ã—æ™‚é–“: ${new Date().toLocaleString()}

**ğŸ¯ ä¸»è¦è­°é¡Œãƒ»å ±å‘Šäº‹é …**
${keyTopics.slice(0, 3).map(topic => `â€¢ ${topic.slice(0, 50)}...`).join('\n') || 'â€¢ ä¸€èˆ¬çš„ãªè­°é¡Œã«ã¤ã„ã¦è­°è«–'}

**âœ… æ±ºå®šäº‹é …ãƒ»çµè«–**
${decisions.slice(0, 2).map(decision => `â€¢ ${decision.slice(0, 50)}...`).join('\n') || 'â€¢ ç¶™ç¶šæ¤œè¨äº‹é …ã‚ã‚Š'}

**ğŸ“‹ ä»Šå¾Œã®å¯¾å¿œãƒ»è¡Œå‹•äº‹é …**
${actions.slice(0, 2).map(action => `â€¢ ${action.slice(0, 50)}...`).join('\n') || 'â€¢ æ¬¡å›ä¼šè­°ã§ç¶™ç¶šè­°è«–'}

**âš ï¸ èª²é¡Œãƒ»æ³¨æ„äº‹é …**
â€¢ è©³ç´°ãªæ¤œè¨ãŒå¿…è¦ãªé …ç›®ã‚ã‚Š
â€¢ é–¢ä¿‚è€…ã¨ã®èª¿æ•´ãŒå¿…è¦`

  console.log("âœ… Simple summary generation completed")
  return result
}

// ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡ºï¼ˆWeb Speech APIç‰ˆ - ç°¡æ˜“ï¼‰
async function extractKeywords(transcript: string) {
  console.log("ğŸ” Starting keyword extraction...")
  console.log("Input transcript length:", transcript.length)
  
  // å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ç›´æ¥ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æŠ½å‡º
  let keywordText = transcript.trim()
  
  if (transcript.length > 3000) {
    console.log("ğŸ“ Long transcript detected, extracting keyword-rich content...")
    
    // å…·ä½“çš„ãªæƒ…å ±ã‚’å«ã‚€æ–‡ã‚’æŠ½å‡º
    const sentences = transcript.split(/[ã€‚ï¼!ï¼?ï¼Ÿ\n]/)
    const keywordRichSentences = sentences.filter(sentence => {
      const trimmed = sentence.trim()
      if (trimmed.length < 8) return false
      
      // å…·ä½“çš„ãªæƒ…å ±ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯
      const hasSpecificInfo = (
        /[0-9]+[å¹´æœˆæ—¥æ™‚åˆ†]|[0-9]+æœŸ|[0-9]+äºº|[0-9]+å›|[0-9]+ä¸‡|[0-9]+å††/.test(trimmed) || // æ•°å€¤æƒ…å ±
        /[A-Z]{2,}|JTSC|ã‚³ãƒ¢ãƒ³|å›³æ›¸å®¤|æ–°è°·|äº•ä¸Š|ç«¹åŸ|æ›å·/.test(trimmed) || // å›ºæœ‰åè©
        /å­¦ç”Ÿ|æˆæ¥­|è©¦é¨“|å’æ¥­|å°±è·|ä¿è­·è€…|å…ˆç”Ÿ|ä¼šè­°|å ±å‘Š|é€£çµ¡|ç›¸è«‡|å•é¡Œ|å¯¾å¿œ/.test(trimmed) // é‡è¦èª
      )
      
      return hasSpecificInfo
    })
    
    console.log("Keyword-rich sentences found:", keywordRichSentences.length)
    keywordText = keywordRichSentences.slice(0, 12).join('ã€‚') + 'ã€‚'
  }

  const prompt = `
ä»¥ä¸‹ã¯å­¦æ ¡ã®ä¼šè­°ã‚„æ¥­å‹™å ±å‘Šã®éŸ³å£°æ–‡å­—èµ·ã“ã—ã§ã™ã€‚
å®Ÿéš›ã«è¨€åŠã•ã‚Œã¦ã„ã‚‹å…·ä½“çš„ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½“ç³»çš„ã«æŠ½å‡ºã—ã¦ãã ã•ã„ã€‚

ã€æ–‡å­—èµ·ã“ã—ãƒ†ã‚­ã‚¹ãƒˆã€‘
${keywordText}

ã€æŠ½å‡ºæŒ‡ç¤ºã€‘
- å®Ÿéš›ã«ãƒ†ã‚­ã‚¹ãƒˆä¸­ã«ç™»å ´ã™ã‚‹å…·ä½“çš„ãªå˜èªã®ã¿ã‚’æŠ½å‡º
- æ¨æ¸¬ã‚„è£œå®Œã¯ã›ãšã€æ˜ç¢ºã«è¨€åŠã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã®ã¿
- ã‚«ãƒ†ã‚´ãƒªåˆ¥ã«æ•´ç†ã—ã¦å‡ºåŠ›

ã€å‡ºåŠ›å½¢å¼ã€‘
## ğŸ·ï¸ æŠ½å‡ºã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰

**ï¿½ äººç‰©ãƒ»çµ„ç¹”**
â€¢ [å®Ÿéš›ã«åå‰ãŒå‡ºãŸäººç‰©]
â€¢ [å®Ÿéš›ã«è¨€åŠã•ã‚ŒãŸçµ„ç¹”ãƒ»éƒ¨ç½²]

**ğŸ“š å­¦äº‹ãƒ»æ¥­å‹™**
â€¢ [å…·ä½“çš„ãªæˆæ¥­ãƒ»æ¥­å‹™å†…å®¹]
â€¢ [è©¦é¨“ãƒ»ã‚¤ãƒ™ãƒ³ãƒˆå]

**ğŸ“… æ—¥æ™‚ãƒ»ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«**  
â€¢ [å…·ä½“çš„ãªæ—¥ä»˜ãƒ»æ™‚æœŸ]
â€¢ [æœŸé™ãƒ»ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«]

**ğŸ¢ å ´æ‰€ãƒ»æ–½è¨­**
â€¢ [å…·ä½“çš„ãªå ´æ‰€å]
â€¢ [æ–½è¨­ãƒ»è¨­å‚™å]

**ğŸ”§ åˆ¶åº¦ãƒ»ã‚·ã‚¹ãƒ†ãƒ **
â€¢ [åˆ¶åº¦åãƒ»ã‚·ã‚¹ãƒ†ãƒ å]
â€¢ [æ‰‹ç¶šããƒ»ãƒ—ãƒ­ã‚»ã‚¹]

**ï¿½ æ•°å€¤ãƒ»ãƒ‡ãƒ¼ã‚¿**
â€¢ [äººæ•°ãƒ»é‡‘é¡ãƒ»æœŸæ•°ãªã©]
â€¢ [çµ±è¨ˆãƒ»å®Ÿç¸¾ãƒ‡ãƒ¼ã‚¿]

**âš ï¸ èª²é¡Œãƒ»å•é¡Œ**
â€¢ [å…·ä½“çš„ãªå•é¡Œå†…å®¹]
â€¢ [æ‡¸å¿µäº‹é …]
`

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [{ role: "user", content: prompt }],
      temperature: 0.1,
      max_tokens: 2000,
    })

    const result = response.choices[0].message.content
    console.log("âœ… Keyword extraction completed with", result?.length || 0, "characters")
    return result
  } catch (error) {
    console.error("âŒ Keyword extraction failed:", error)
    return "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + (error instanceof Error ? error.message : String(error))
  }
}

// æ„Ÿæƒ…åˆ†æ
async function analyzeSentiment(transcript: string, openai: OpenAI) {
  console.log("ğŸ­ Starting sentiment analysis...")
  console.log("Input transcript length:", transcript.length)
  
  // æ„Ÿæƒ…è¡¨ç¾ã‚’å«ã‚€éƒ¨åˆ†ã‚’ç‰¹å®š
  let sentimentText = transcript.trim()
  
  if (transcript.length > 2500) {
    console.log("ğŸ“ Long transcript detected, focusing on emotional and interpersonal content...")
    
    const sentences = transcript.split(/[ã€‚ï¼!ï¼?ï¼Ÿ\n]/)
    const emotionalSentences = sentences.filter(sentence => {
      const trimmed = sentence.trim()
      if (trimmed.length < 8) return false
      
      // æ„Ÿæƒ…çš„ãƒ»å¯¾äººçš„ãªè¡¨ç¾ã‚’ã‚ˆã‚Šåºƒãæ¤œå‡º
      const hasEmotionalContent = (
        /ã‚ã‚ŠãŒãŸ|æ„Ÿè¬|å¿ƒé…|æ€–ã„|å¬‰ã—ã„|å¤§å¤‰|å›°ã£|å•é¡Œ|è‰¯ã„|æ‚ªã„|ã™ã”ã„|ã³ã£ãã‚Š|å®‰å¿ƒ|ä¸å®‰|æº€è¶³|ä¸æº€/.test(trimmed) ||
        /ã‚¯ãƒ¬ãƒ¼ãƒ |è‹¦æƒ…|ç›¸è«‡|ãŠç–²ã‚Œ|ã™ã¿ã¾ã›ã‚“|ç”³ã—è¨³|æç¸®|åŠ©ã‹|è¿·æƒ‘|è² æ‹…|ã‚¹ãƒˆãƒ¬ã‚¹/.test(trimmed) ||
        /é ‘å¼µ|åŠªåŠ›|å”åŠ›|æ”¯æ´|ã‚µãƒãƒ¼ãƒˆ|æ”¹å–„|å‘ä¸Š|æˆé•·|é”æˆ|æˆåŠŸ|å¤±æ•—|æŒ«æŠ˜/.test(trimmed) ||
        /å¿™ã—|ç–²ã‚Œ|è¾›ã„|æ¥½ã—|é¢ç™½|ã¤ã¾ã‚‰|é€€å±ˆ|èˆˆå‘³|é–¢å¿ƒ|ã‚„ã‚‹æ°—|ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³/.test(trimmed)
      )
      
      return hasEmotionalContent
    })
    
    console.log("Emotional sentences found:", emotionalSentences.length)
    
    if (emotionalSentences.length > 0) {
      sentimentText = emotionalSentences.slice(0, 10).join('ã€‚') + 'ã€‚'
    } else {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šå¯¾è©±çš„ãªéƒ¨åˆ†ã‚’æŠ½å‡º
      const dialogueSentences = sentences.filter(s => 
        /ã¯ã„|ãˆãˆ|ãã†ã§ã™|ãã†ã§ã™ã­|ãªã‚‹ã»ã©|ãã†ã„ã†ã“ã¨|åˆ†ã‹ã‚Šã¾ã—ãŸ|äº†è§£|æ‰¿çŸ¥/.test(s)
      )
      sentimentText = dialogueSentences.slice(0, 8).join('ã€‚') + 'ã€‚'
    }
  }

  const prompt = `
ä»¥ä¸‹ã¯å­¦æ ¡ã®ä¼šè­°ã‚„æ¥­å‹™å ±å‘Šã®éŸ³å£°æ–‡å­—èµ·ã“ã—ã§ã™ã€‚
ç™ºè¨€è€…ã®æ„Ÿæƒ…ã€é–¢ä¿‚æ€§ã€ä¼šè­°ã®é›°å›²æ°—ã‚’è©³ç´°ã«åˆ†æã—ã¦ãã ã•ã„ã€‚

ã€æ–‡å­—èµ·ã“ã—ãƒ†ã‚­ã‚¹ãƒˆã€‘
${sentimentText}

ã€åˆ†ææŒ‡ç¤ºã€‘
1. å®Ÿéš›ã®ç™ºè¨€ã‹ã‚‰èª­ã¿å–ã‚Œã‚‹æ„Ÿæƒ…çš„è¦ç´ ã‚’å…·ä½“çš„ã«åˆ†æ
2. å‚åŠ è€…åŒå£«ã®é–¢ä¿‚æ€§ã‚„ç›¸äº’ä½œç”¨ã‚’è¦³å¯Ÿ
3. ä¼šè­°å…¨ä½“ã®é›°å›²æ°—ã‚„é€²è¡Œã®æ§˜å­ã‚’è©•ä¾¡
4. ã‚¹ãƒˆãƒ¬ã‚¹è¦å› ã‚„èª²é¡Œã«é–¢ã™ã‚‹æ„Ÿæƒ…çš„åå¿œã‚’ç‰¹å®š

ã€å‡ºåŠ›å½¢å¼ã€‘
## ğŸ­ æ„Ÿæƒ…ãƒ»é›°å›²æ°—åˆ†æ

**ï¿½ å…¨ä½“çš„ãªæ„Ÿæƒ…ãƒˆãƒ¼ãƒ³**
[ãƒã‚¸ãƒ†ã‚£ãƒ–/ãƒã‚¬ãƒ†ã‚£ãƒ–/ä¸­ç«‹] - å¼·åº¦: [å¼±ã„/æ™®é€š/å¼·ã„]
[å…·ä½“çš„ãªæ ¹æ‹ ã¨ãªã‚‹ç™ºè¨€ã‚„è¡¨ç¾]

**ï¿½ æ„Ÿæƒ…çš„ãªç™ºè¨€ãƒ»åå¿œ**
â€¢ [ç™ºè¨€å†…å®¹]: [èƒŒæ™¯ãƒ»æ–‡è„ˆã®èª¬æ˜]
â€¢ [ç™ºè¨€å†…å®¹]: [èƒŒæ™¯ãƒ»æ–‡è„ˆã®èª¬æ˜]
â€¢ [ç™ºè¨€å†…å®¹]: [èƒŒæ™¯ãƒ»æ–‡è„ˆã®èª¬æ˜]

**ğŸ¤ å‚åŠ è€…ã®é–¢ä¿‚æ€§**
[ä¸Šä¸‹é–¢ä¿‚ã€å”åŠ›é–¢ä¿‚ã€å¯¾ç«‹é–¢ä¿‚ãªã©ã®è¦³å¯Ÿçµæœ]

**ğŸŒ¡ï¸ ä¼šè­°ã®é›°å›²æ°—**
[é€²è¡Œã®æ§˜å­ã€ç©æ¥µæ€§ã€å»ºè¨­æ€§ã€ç·Šå¼µæ„Ÿãªã©ã®ç‰¹å¾´]

**âš ï¸ æ³¨æ„ã™ã¹ãæ„Ÿæƒ…çš„è¦ç´ **
â€¢ [ã‚¹ãƒˆãƒ¬ã‚¹ãƒ»ä¸å®‰ã®å…†å€™]
â€¢ [èª²é¡Œãƒ»å•é¡Œã«å¯¾ã™ã‚‹åå¿œ]
â€¢ [æ”¹å–„ãŒå¿…è¦ãªç‚¹]

**âœ¨ ãƒã‚¸ãƒ†ã‚£ãƒ–ãªè¦ç´ **
â€¢ [å”åŠ›çš„ãªæ…‹åº¦]
â€¢ [å»ºè¨­çš„ãªææ¡ˆ]
â€¢ [é”æˆæ„Ÿãƒ»æº€è¶³æ„Ÿã®è¡¨ç¾]
`

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [{ role: "user", content: prompt }],
      temperature: 0.2,
      max_tokens: 2000,
    })

    const result = response.choices[0].message.content
    console.log("âœ… Sentiment analysis completed with", result?.length || 0, "characters")
    return result
  } catch (error) {
    console.error("âŒ Sentiment analysis failed:", error)
    return "æ„Ÿæƒ…åˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + (error instanceof Error ? error.message : String(error))
  }
}

// æ–‡ç« æ§‹é€ åŒ–
async function structureTranscript(transcript: string, openai: OpenAI) {
  const prompt = `
  ä»¥ä¸‹ã®æ–‡å­—èµ·ã“ã—ãƒ†ã‚­ã‚¹ãƒˆã‚’èª­ã¿ã‚„ã™ãæ§‹é€ åŒ–ã—ã¦ãã ã•ã„ã€‚
  
  æ§‹é€ åŒ–ã®æ–¹é‡ï¼š
  1. é©åˆ‡ãªæ®µè½åˆ†å‰²
  2. æ–‡ç« ã®æ•´ç†ï¼ˆå†—é•·ãªéƒ¨åˆ†ã®å‰Šé™¤ï¼‰
  3. è©±é¡Œã®åŒºåˆ‡ã‚Šã‚’æ˜ç¢ºã«
  4. è¦‹å‡ºã—ã®è¿½åŠ ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
  5. èª­ã¿ã‚„ã™ã„æ–‡ä½“ã«èª¿æ•´

  ãƒ†ã‚­ã‚¹ãƒˆï¼š
  ${transcript}
  `

  const response = await openai.chat.completions.create({
    model: "gpt-4",
    messages: [{ role: "user", content: prompt }],
    temperature: 0.3,
  })

  return response.choices[0].message.content
}
